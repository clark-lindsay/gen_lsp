{"jsonrpc":"2.0","method":"textDocument\/didOpen","params":{"textDocument":{"version":0,"text":"defmodule Phoenix.Controller do\n  import Plug.Conn\n  alias Plug.Conn.AlreadySentError\n\n  require Logger\n  require Phoenix.Endpoint\n\n  @unsent [:unset, :set, :set_chunked, :set_file]\n     \n  @moduledoc \"\"\"\n  Controllers are used to group common functionality in the same\n  (pluggable) module.\n\n  For example, the route:\n\n      get \"\/users\/:id\", MyAppWeb.UserController, :show\n\n  will invoke the `show\/2` action in the `MyAppWeb.UserController`:\n\n      defmodule MyAppWeb.UserController do\n        use MyAppWeb, :controller\n\n        def show(conn, %{\"id\" => id}) do\n          user = Repo.get(User, id)\n          render(conn, \"show.html\", user: user)\n        end\n      end\n\n  An action is a regular function that receives the connection\n  and the request parameters as arguments. The connection is a\n  `Plug.Conn` struct, as specified by the Plug library.\n\n  ## Options\n\n  When used, the controller supports the following options:\n\n    * `:namespace` - sets the namespace to properly inflect\n      the layout view. By default it uses the base alias\n      in your controller name\n\n    * `:put_default_views` - controls whether the default view\n      and layout should be set or not\n\n  ## Connection\n\n  A controller by default provides many convenience functions for\n  manipulating the connection, rendering templates, and more.\n\n  Those functions are imported from two modules:\n\n    * `Plug.Conn` - a collection of low-level functions to work with\n      the connection\n\n    * `Phoenix.Controller` - functions provided by Phoenix\n      to support rendering, and other Phoenix specific behaviour\n\n  If you want to have functions that manipulate the connection\n  without fully implementing the controller, you can import both\n  modules directly instead of `use Phoenix.Controller`.\n\n  ## Plug pipeline\n\n  As with routers, controllers also have their own plug pipeline.\n  However, different from routers, controllers have a single pipeline:\n\n      defmodule MyAppWeb.UserController do\n        use MyAppWeb, :controller\n\n        plug :authenticate, usernames: [\"jose\", \"eric\", \"sonny\"]\n\n        def show(conn, params) do\n          # authenticated users only\n        end\n\n        defp authenticate(conn, options) do\n          if get_session(conn, :username) in options[:usernames] do\n            conn\n          else\n            conn |> redirect(to: \"\/\") |> halt()\n          end\n        end\n      end\n\n  The `:authenticate` plug will be invoked before the action. If the\n  plug calls `Plug.Conn.halt\/1` (which is by default imported into\n  controllers), it will halt the pipeline and won't invoke the action.\n\n  ### Guards\n\n  `plug\/2` in controllers supports guards, allowing a developer to configure\n  a plug to only run in some particular action:\n\n      plug :authenticate, [usernames: [\"jose\", \"eric\", \"sonny\"]] when action in [:show, :edit]\n      plug :authenticate, [usernames: [\"admin\"]] when not action in [:index]\n\n  The first plug will run only when action is show or edit. The second plug will\n  always run, except for the index action.\n\n  Those guards work like regular Elixir guards and the only variables accessible\n  in the guard are `conn`, the `action` as an atom and the `controller` as an\n  alias.\n\n  ## Controllers are plugs\n\n  Like routers, controllers are plugs, but they are wired to dispatch\n  to a particular function which is called an action.\n\n  For example, the route:\n\n      get \"\/users\/:id\", UserController, :show\n\n  will invoke `UserController` as a plug:\n\n      UserController.call(conn, :show)\n\n  which will trigger the plug pipeline and which will eventually\n  invoke the inner action plug that dispatches to the `show\/2`\n  function in `UserController`.\n\n  As controllers are plugs, they implement both [`init\/1`](`c:Plug.init\/1`) and\n  [`call\/2`](`c:Plug.call\/2`), and it also provides a function named `action\/2`\n  which is responsible for dispatching the appropriate action\n  after the plug stack (and is also overridable).\n\n  ### Overriding `action\/2` for custom arguments\n\n  Phoenix injects an `action\/2` plug in your controller which calls the\n  function matched from the router. By default, it passes the conn and params.\n  In some cases, overriding the `action\/2` plug in your controller is a\n  useful way to inject arguments into your actions that you would otherwise\n  need to repeatedly fetch off the connection. For example, imagine if you\n  stored a `conn.assigns.current_user` in the connection and wanted quick\n  access to the user for every action in your controller:\n\n      def action(conn, _) do\n        args = [conn, conn.params, conn.assigns.current_user]\n        apply(__MODULE__, action_name(conn), args)\n      end\n\n      def index(conn, _params, user) do\n        videos = Repo.all(user_videos(user))\n        # ...\n      end\n\n      def delete(conn, %{\"id\" => id}, user) do\n        video = Repo.get!(user_videos(user), id)\n        # ...\n      end\n\n  ## Rendering and layouts\n\n  One of the main features provided by controllers is the ability\n  to perform content negotiation and render templates based on\n  information sent by the client. Read `render\/3` to learn more.\n\n  It is also important not to confuse `Phoenix.Controller.render\/3`\n  with `Phoenix.View.render\/3`. The former expects\n  a connection and relies on content negotiation while the latter is\n  connection-agnostic and typically invoked from your views.\n  \"\"\"\n  defmacro __using__(opts) do\n    quote bind_quoted: [opts: opts] do\n      import Phoenix.Controller\n\n      # TODO v2: No longer automatically import dependencies\n      import Plug.Conn\n\n      use Phoenix.Controller.Pipeline\n\n      if Keyword.get(opts, :put_default_views, true) do\n        plug :put_new_layout, {Phoenix.Controller.__layout__(__MODULE__, opts), :app}\n        plug :put_new_view, Phoenix.Controller.__view__(__MODULE__)\n      end\n    end\n  end\n\n  @doc \"\"\"\n  Registers the plug to call as a fallback to the controller action.\n\n  A fallback plug is useful to translate common domain data structures\n  into a valid `%Plug.Conn{}` response. If the controller action fails to\n  return a `%Plug.Conn{}`, the provided plug will be called and receive\n  the controller's `%Plug.Conn{}` as it was before the action was invoked\n  along with the value returned from the controller action.\n\n  ## Examples\n\n      defmodule MyController do\n        use Phoenix.Controller\n\n        action_fallback MyFallbackController\n\n        def show(conn, %{\"id\" => id}, current_user) do\n          with {:ok, post} <- Blog.fetch_post(id),\n               :ok <- Authorizer.authorize(current_user, :view, post) do\n\n            render(conn, \"show.json\", post: post)\n          end\n        end\n      end\n\n  In the above example, `with` is used to match only a successful\n  post fetch, followed by valid authorization for the current user.\n  In the event either of those fail to match, `with` will not invoke\n  the render block and instead return the unmatched value. In this case,\n  imagine `Blog.fetch_post\/2` returned `{:error, :not_found}` or\n  `Authorizer.authorize\/3` returned `{:error, :unauthorized}`. For cases\n  where these data structures serve as return values across multiple\n  boundaries in our domain, a single fallback module can be used to\n  translate the value into a valid response. For example, you could\n  write the following fallback controller to handle the above values:\n\n      defmodule MyFallbackController do\n        use Phoenix.Controller\n\n        def call(conn, {:error, :not_found}) do\n          conn\n          |> put_status(:not_found)\n          |> put_view(MyErrorView)\n          |> render(:\"404\")\n        end\n\n        def call(conn, {:error, :unauthorized}) do\n          conn\n          |> put_status(403)\n          |> put_view(MyErrorView)\n          |> render(:\"403\")\n        end\n      end\n  \"\"\"\n  defmacro action_fallback(plug) do\n    Phoenix.Controller.Pipeline.__action_fallback__(plug, __CALLER__)\n  end\n\n  @doc \"\"\"\n  Returns the action name as an atom, raises if unavailable.\n  \"\"\"\n  @spec action_name(Plug.Conn.t) :: atom\n  def action_name(conn), do: conn.private.phoenix_action\n\n  @doc \"\"\"\n  Returns the controller module as an atom, raises if unavailable.\n  \"\"\"\n  @spec controller_module(Plug.Conn.t) :: atom\n  def controller_module(conn), do: conn.private.phoenix_controller\n\n  @doc \"\"\"\n  Returns the router module as an atom, raises if unavailable.\n  \"\"\"\n  @spec router_module(Plug.Conn.t) :: atom\n  def router_module(conn), do: conn.private.phoenix_router\n\n  @doc \"\"\"\n  Returns the endpoint module as an atom, raises if unavailable.\n  \"\"\"\n  @spec endpoint_module(Plug.Conn.t) :: atom\n  def endpoint_module(conn), do: conn.private.phoenix_endpoint\n\n  @doc \"\"\"\n  Returns the template name rendered in the view as a string\n  (or nil if no template was rendered).\n  \"\"\"\n  @spec view_template(Plug.Conn.t) :: binary | nil\n  def view_template(conn) do\n    conn.private[:phoenix_template]\n  end\n\n  @doc \"\"\"\n  Sends JSON response.\n\n  It uses the configured `:json_library` under the `:phoenix`\n  application for `:json` to pick up the encoder module.\n\n  ## Examples\n\n      iex> json(conn, %{id: 123})\n\n  \"\"\"\n  @spec json(Plug.Conn.t, term) :: Plug.Conn.t\n  def json(conn, data) do\n    response = Phoenix.json_library().encode_to_iodata!(data)\n    send_resp(conn, conn.status || 200, \"application\/json\", response)\n  end\n\n  @doc \"\"\"\n  A plug that may convert a JSON response into a JSONP one.\n\n  In case a JSON response is returned, it will be converted\n  to a JSONP as long as the callback field is present in\n  the query string. The callback field itself defaults to\n  \"callback\", but may be configured with the callback option.\n\n  In case there is no callback or the response is not encoded\n  in JSON format, it is a no-op.\n\n  Only alphanumeric characters and underscore are allowed in the\n  callback name. Otherwise an exception is raised.\n\n  ## Examples\n\n      # Will convert JSON to JSONP if callback=someFunction is given\n      plug :allow_jsonp\n\n      # Will convert JSON to JSONP if cb=someFunction is given\n      plug :allow_jsonp, callback: \"cb\"\n\n  \"\"\"\n  @spec allow_jsonp(Plug.Conn.t, Keyword.t) :: Plug.Conn.t\n  def allow_jsonp(conn, opts \\\\ []) do\n    callback = Keyword.get(opts, :callback, \"callback\")\n    case Map.fetch(conn.query_params, callback) do\n      :error    -> conn\n      {:ok, \"\"} -> conn\n      {:ok, cb} ->\n        validate_jsonp_callback!(cb)\n        register_before_send(conn, fn conn ->\n          if json_response?(conn) do\n            conn\n            |> put_resp_header(\"content-type\", \"application\/javascript\")\n            |> resp(conn.status, jsonp_body(conn.resp_body, cb))\n          else\n            conn\n          end\n        end)\n    end\n  end\n\n  defp json_response?(conn) do\n    case get_resp_header(conn, \"content-type\") do\n      [\"application\/json;\" <> _] -> true\n      [\"application\/json\"] -> true\n      _ -> false\n    end\n  end\n\n  defp jsonp_body(data, callback) do\n    body =\n      data\n      |> IO.iodata_to_binary()\n      |> String.replace(<<0x2028::utf8>>, \"\\\\u2028\")\n      |> String.replace(<<0x2029::utf8>>, \"\\\\u2029\")\n\n    \"\/**\/ typeof #{callback} === 'function' && #{callback}(#{body});\"\n  end\n\n  defp validate_jsonp_callback!(<<h, t::binary>>)\n    when h in ?0..?9 or h in ?A..?Z or h in ?a..?z or h == ?_,\n    do: validate_jsonp_callback!(t)\n  defp validate_jsonp_callback!(<<>>), do: :ok\n  defp validate_jsonp_callback!(_),\n    do: raise(ArgumentError, \"the JSONP callback name contains invalid characters\")\n\n  @doc \"\"\"\n  Sends text response.\n\n  ## Examples\n\n      iex> text(conn, \"hello\")\n\n      iex> text(conn, :implements_to_string)\n\n  \"\"\"\n  @spec text(Plug.Conn.t, String.Chars.t) :: Plug.Conn.t\n  def text(conn, data) do\n    send_resp(conn, conn.status || 200, \"text\/plain\", to_string(data))\n  end\n\n  @doc \"\"\"\n  Sends html response.\n\n  ## Examples\n\n      iex> html(conn, \"<html><head>...\")\n\n  \"\"\"\n  @spec html(Plug.Conn.t, iodata) :: Plug.Conn.t\n  def html(conn, data) do\n    send_resp(conn, conn.status || 200, \"text\/html\", data)\n  end\n\n  @doc \"\"\"\n  Sends redirect response to the given url.\n\n  For security, `:to` only accepts paths. Use the `:external`\n  option to redirect to any URL.\n\n  The response will be sent with the status code defined within\n  the connection, via `Plug.Conn.put_status\/2`. If no status\n  code is set, a 302 response is sent.\n\n  ## Examples\n\n      iex> redirect(conn, to: \"\/login\")\n\n      iex> redirect(conn, external: \"https:\/\/elixir-lang.org\")\n\n  \"\"\"\n  def redirect(conn, opts) when is_list(opts) do\n    url  = url(opts)\n    html = Plug.HTML.html_escape(url)\n    body = \"<html><body>You are being <a href=\\\"#{html}\\\">redirected<\/a>.<\/body><\/html>\"\n\n    conn\n    |> put_resp_header(\"location\", url)\n    |> send_resp(conn.status || 302, \"text\/html\", body)\n  end\n\n  defp url(opts) do\n    cond do\n      to = opts[:to] -> validate_local_url(to)\n      external = opts[:external] -> external\n      true -> raise ArgumentError, \"expected :to or :external option in redirect\/2\"\n    end\n  end\n  @invalid_local_url_chars [\"\\\\\"]\n  defp validate_local_url(\"\/\/\" <> _ = to), do: raise_invalid_url(to)\n  defp validate_local_url(\"\/\" <> _ = to) do\n    if String.contains?(to, @invalid_local_url_chars) do\n      raise ArgumentError, \"unsafe characters detected for local redirect in URL #{inspect to}\"\n    else\n      to\n    end\n  end\n  defp validate_local_url(to), do: raise_invalid_url(to)\n\n  @spec raise_invalid_url(term()) :: no_return()\n  defp raise_invalid_url(url) do\n    raise ArgumentError, \"the :to option in redirect expects a path but was #{inspect url}\"\n  end\n\n  @doc \"\"\"\n  Stores the view for rendering.\n\n  Raises `Plug.Conn.AlreadySentError` if `conn` is already sent.\n  \"\"\"\n  @spec put_view(Plug.Conn.t, atom) :: Plug.Conn.t\n  def put_view(%Plug.Conn{state: state} = conn, module) when state in @unsent do\n    put_private(conn, :phoenix_view, module)\n  end\n\n  def put_view(%Plug.Conn{}, _module), do: raise AlreadySentError\n\n  @doc \"\"\"\n  Stores the view for rendering if one was not stored yet.\n\n  Raises `Plug.Conn.AlreadySentError` if `conn` is already sent.\n  \"\"\"\n  @spec put_new_view(Plug.Conn.t, atom) :: Plug.Conn.t\n  def put_new_view(%Plug.Conn{state: state} = conn, module)\n      when state in @unsent do\n    update_in conn.private, &Map.put_new(&1, :phoenix_view, module)\n  end\n\n  def put_new_view(%Plug.Conn{}, _module), do: raise AlreadySentError\n\n  @doc \"\"\"\n  Retrieves the current view.\n  \"\"\"\n  @spec view_module(Plug.Conn.t) :: atom\n  def view_module(conn), do: conn.private.phoenix_view\n\n  @doc \"\"\"\n  Stores the layout for rendering.\n\n  The layout must be a tuple, specifying the layout view and the layout\n  name, or false. In case a previous layout is set, `put_layout` also\n  accepts the layout name to be given as a string or as an atom. If a\n  string, it must contain the format. Passing an atom means the layout\n  format will be found at rendering time, similar to the template in\n  `render\/3`. It can also be set to `false`. In this case, no layout\n  would be used.\n\n  ## Examples\n\n      iex> layout(conn)\n      false\n\n      iex> conn = put_layout conn, {AppView, \"application.html\"}\n      iex> layout(conn)\n      {AppView, \"application.html\"}\n\n      iex> conn = put_layout conn, \"print.html\"\n      iex> layout(conn)\n      {AppView, \"print.html\"}\n\n      iex> conn = put_layout conn, :print\n      iex> layout(conn)\n      {AppView, :print}\n\n  Raises `Plug.Conn.AlreadySentError` if `conn` is already sent.\n  \"\"\"\n  @spec put_layout(Plug.Conn.t, {atom, binary | atom} | atom | binary | false) :: Plug.Conn.t\n  def put_layout(%Plug.Conn{state: state} = conn, layout) do\n    if state in @unsent do\n      do_put_layout(conn, :phoenix_layout, layout)\n    else\n      raise AlreadySentError\n    end\n  end\n\n  defp do_put_layout(conn, private_key, false) do\n    put_private(conn, private_key, false)\n  end\n\n  defp do_put_layout(conn, private_key, {mod, layout}) when is_atom(mod) do\n    put_private(conn, private_key, {mod, layout})\n  end\n\n  defp do_put_layout(conn, private_key, layout) when is_binary(layout) or is_atom(layout) do\n    update_in conn.private, fn private ->\n      case Map.get(private, private_key, false) do\n        {mod, _} -> Map.put(private, private_key, {mod, layout})\n        false    -> raise \"cannot use put_layout\/2  or put_root_layout\/2 with atom\/binary when layout is false, use a tuple instead\"\n      end\n    end\n  end\n\n  @doc \"\"\"\n  Stores the layout for rendering if one was not stored yet.\n\n  Raises `Plug.Conn.AlreadySentError` if `conn` is already sent.\n  \"\"\"\n  @spec put_new_layout(Plug.Conn.t, {atom, binary | atom} | false) :: Plug.Conn.t\n  def put_new_layout(%Plug.Conn{state: state} = conn, layout)\n      when (is_tuple(layout) and tuple_size(layout) == 2) or layout == false do\n    if state in @unsent do\n      update_in conn.private, &Map.put_new(&1, :phoenix_layout, layout)\n    else\n      raise AlreadySentError\n    end\n  end\n\n  @doc \"\"\"\n  Stores the root layout for rendering.\n\n  Like `put_layout\/2`, the layout must be a tuple,\n  specifying the layout view and the layout name, or false.\n\n  In case a previous layout is set, `put_root_layout` also\n  accepts the layout name to be given as a string or as an atom. If a\n  string, it must contain the format. Passing an atom means the layout\n  format will be found at rendering time, similar to the template in\n  `render\/3`. It can also be set to `false`. In this case, no layout\n  would be used.\n\n  ## Examples\n\n      iex> root_layout(conn)\n      false\n\n      iex> conn = put_root_layout conn, {AppView, \"root.html\"}\n      iex> root_layout(conn)\n      {AppView, \"root.html\"}\n\n      iex> conn = put_root_layout conn, \"bare.html\"\n      iex> root_layout(conn)\n      {AppView, \"bare.html\"}\n\n      iex> conn = put_root_layout conn, :bare\n      iex> root_layout(conn)\n      {AppView, :bare}\n\n  Raises `Plug.Conn.AlreadySentError` if `conn` is already sent.\n  \"\"\"\n  @spec put_root_layout(Plug.Conn.t, {atom, binary | atom} | atom | binary | false) :: Plug.Conn.t\n  def put_root_layout(%Plug.Conn{state: state} = conn, layout) do\n    if state in @unsent do\n      do_put_layout(conn, :phoenix_root_layout, layout)\n    else\n      raise AlreadySentError\n    end\n  end\n\n  @doc \"\"\"\n  Sets which formats have a layout when rendering.\n\n  ## Examples\n\n      iex> layout_formats(conn)\n      [\"html\"]\n\n      iex> put_layout_formats(conn, [\"html\", \"mobile\"])\n      iex> layout_formats(conn)\n      [\"html\", \"mobile\"]\n\n  Raises `Plug.Conn.AlreadySentError` if `conn` is already sent.\n  \"\"\"\n  @spec put_layout_formats(Plug.Conn.t, [String.t]) :: Plug.Conn.t\n  def put_layout_formats(%Plug.Conn{state: state} = conn, formats)\n      when state in @unsent and is_list(formats) do\n    put_private(conn, :phoenix_layout_formats, formats)\n  end\n\n  def put_layout_formats(%Plug.Conn{}, _formats), do: raise AlreadySentError\n\n  @doc \"\"\"\n  Retrieves current layout formats.\n  \"\"\"\n  @spec layout_formats(Plug.Conn.t) :: [String.t]\n  def layout_formats(conn) do\n    Map.get(conn.private, :phoenix_layout_formats, ~w(html))\n  end\n\n  @doc \"\"\"\n  Retrieves the current layout.\n  \"\"\"\n  @spec layout(Plug.Conn.t) :: {atom, String.t | atom} | false\n  def layout(conn), do: conn.private |> Map.get(:phoenix_layout, false)\n\n  @doc \"\"\"\n  Retrieves the current root layout.\n  \"\"\"\n  @spec root_layout(Plug.Conn.t) :: {atom, String.t | atom} | false\n  def root_layout(conn), do: conn.private |> Map.get(:phoenix_root_layout, false)\n\n  @doc \"\"\"\n  Render the given template or the default template\n  specified by the current action with the given assigns.\n\n  See `render\/3` for more information.\n  \"\"\"\n  @spec render(Plug.Conn.t, Keyword.t | map | binary | atom) :: Plug.Conn.t\n  def render(conn, template_or_assigns \\\\ [])\n\n  def render(conn, template) when is_binary(template) or is_atom(template) do\n    render(conn, template, [])\n  end\n\n  def render(conn, assigns) do\n    render(conn, action_name(conn), assigns)\n  end\n\n  @doc \"\"\"\n  Renders the given `template` and `assigns` based on the `conn` information.\n\n  Once the template is rendered, the template format is set as the response\n  content type (for example, an HTML template will set \"text\/html\" as response\n  content type) and the data is sent to the client with default status of 200.\n\n  ## Arguments\n\n    * `conn` - the `Plug.Conn` struct\n\n    * `template` - which may be an atom or a string. If an atom, like `:index`,\n      it will render a template with the same format as the one returned by\n      `get_format\/1`. For example, for an HTML request, it will render\n      the \"index.html\" template. If the template is a string, it must contain\n      the extension too, like \"index.json\"\n\n    * `assigns` - a dictionary with the assigns to be used in the view. Those\n      assigns are merged and have higher precedence than the connection assigns\n      (`conn.assigns`)\n\n  ## Examples\n\n      defmodule MyAppWeb.UserController do\n        use Phoenix.Controller\n\n        def show(conn, _params) do\n          render(conn, \"show.html\", message: \"Hello\")\n        end\n      end\n\n  The example above renders a template \"show.html\" from the `MyAppWeb.UserView`\n  and sets the response content type to \"text\/html\".\n\n  In many cases, you may want the template format to be set dynamically based\n  on the request. To do so, you can pass the template name as an atom (without\n  the extension):\n\n      def show(conn, _params) do\n        render(conn, :show, message: \"Hello\")\n      end\n\n  In order for the example above to work, we need to do content negotiation with\n  the accepts plug before rendering. You can do so by adding the following to your\n  pipeline (in the router):\n\n      plug :accepts, [\"html\"]\n\n  ## Views\n\n  By default, Controllers render templates in a view with a similar name to the\n  controller. For example, `MyAppWeb.UserController` will render templates inside\n  the `MyAppWeb.UserView`. This information can be changed any time by using the\n  `put_view\/2` function:\n\n      def show(conn, _params) do\n        conn\n        |> put_view(MyAppWeb.SpecialView)\n        |> render(:show, message: \"Hello\")\n      end\n\n  `put_view\/2` can also be used as a plug:\n\n      defmodule MyAppWeb.UserController do\n        use Phoenix.Controller\n\n        plug :put_view, MyAppWeb.SpecialView\n\n        def show(conn, _params) do\n          render(conn, :show, message: \"Hello\")\n        end\n      end\n\n  ## Layouts\n\n  Templates are often rendered inside layouts. By default, Phoenix\n  will render layouts for html requests. For example:\n\n      defmodule MyAppWeb.UserController do\n        use Phoenix.Controller\n\n        def show(conn, _params) do\n          render(conn, \"show.html\", message: \"Hello\")\n        end\n      end\n\n  will render the  \"show.html\" template inside an \"app.html\"\n  template specified in `MyAppWeb.LayoutView`. `put_layout\/2` can be used\n  to change the layout, similar to how `put_view\/2` can be used to change\n  the view.\n\n  `layout_formats\/1` and `put_layout_formats\/2` can be used to configure\n  which formats support\/require layout rendering (defaults to \"html\" only).\n  \"\"\"\n  @spec render(Plug.Conn.t, binary | atom, Keyword.t | map) :: Plug.Conn.t\n  def render(conn, template, assigns)\n      when is_atom(template) and (is_map(assigns) or is_list(assigns)) do\n    format =\n      get_format(conn) ||\n      raise \"cannot render template #{inspect template} because conn.params[\\\"_format\\\"] is not set. \" <>\n            \"Please set `plug :accepts, ~w(html json ...)` in your pipeline.\"\n\n    render_and_send(conn, format, template, assigns)\n  end\n\n  def render(conn, template, assigns)\n      when is_binary(template) and (is_map(assigns) or is_list(assigns)) do\n    case Path.extname(template) do\n      \".\" <> format ->\n        render_and_send(conn, format, template, assigns)\n      \"\" ->\n        raise \"cannot render template #{inspect template} without format. Use an atom if the \" <>\n              \"template format is meant to be set dynamically based on the request format\"\n    end\n  end\n\n  def render(conn, view, template)\n      when is_atom(view) and (is_binary(template) or is_atom(template)) do\n    IO.warn \"#{__MODULE__}.render\/3 with a view is deprecated, see the documentation for render\/3 for an alternative\"\n    render(conn, view, template, [])\n  end\n\n  @doc false\n  @deprecated \"render\/4 is deprecated. Use put_view + render\/3\"\n  def render(conn, view, template, assigns)\n      when is_atom(view) and (is_binary(template) or is_atom(template)) do\n    conn\n    |> put_view(view)\n    |> render(template, assigns)\n  end\n\n  defp render_and_send(conn, format, template, assigns) do\n    template = template_name(template, format)\n    view =\n      Map.get(conn.private, :phoenix_view) ||\n        raise \"a view module was not specified, set one with put_view\/2\"\n\n    layout_format? = format in layout_formats(conn)\n    conn = prepare_assigns(conn, assigns, template, format, layout_format?)\n    data = render_with_layouts(conn, view, template, format, layout_format?)\n\n    conn\n    |> ensure_resp_content_type(MIME.type(format))\n    |> send_resp(conn.status || 200, data)\n  end\n\n  defp render_with_layouts(conn, view, template, format, layout_format?) do\n    render_assigns = Map.put(conn.assigns, :conn, conn)\n\n    case layout_format? and root_layout(conn) do\n      {layout_mod, layout_tpl} ->\n        inner = Phoenix.View.render(view, template, render_assigns)\n        root_assigns = render_assigns |> Map.put(:inner_content, inner) |> Map.delete(:layout)\n        Phoenix.View.render_to_iodata(layout_mod, template_name(layout_tpl, format), root_assigns)\n\n      false ->\n        Phoenix.View.render_to_iodata(view, template, render_assigns)\n    end\n  end\n\n  defp prepare_assigns(conn, assigns, template, format, layout_format?) do\n    assigns = to_map(assigns)\n\n    layout =\n      case layout_format? and assigns_layout(conn, assigns) do\n        {mod, layout} -> {mod, template_name(layout, format)}\n        false -> false\n      end\n\n    conn\n    |> put_private(:phoenix_template, template)\n    |> Map.update!(:assigns, fn prev ->\n      prev\n      |> Map.merge(assigns)\n      |> Map.put(:layout, layout)\n    end)\n  end\n\n  defp assigns_layout(conn, assigns) do\n    case Map.fetch(assigns, :layout) do\n      {:ok, layout} -> layout\n      :error -> layout(conn)\n    end\n  end\n\n  defp to_map(assigns) when is_map(assigns), do: assigns\n  defp to_map(assigns) when is_list(assigns), do: :maps.from_list(assigns)\n\n  defp template_name(name, format) when is_atom(name), do:\n    Atom.to_string(name) <> \".\" <> format\n  defp template_name(name, _format) when is_binary(name), do:\n    name\n\n  defp send_resp(conn, default_status, default_content_type, body) do\n    conn\n    |> ensure_resp_content_type(default_content_type)\n    |> send_resp(conn.status || default_status, body)\n  end\n\n  defp ensure_resp_content_type(%Plug.Conn{resp_headers: resp_headers} = conn, content_type) do\n    if List.keyfind(resp_headers, \"content-type\", 0) do\n      conn\n    else\n      content_type = content_type <> \"; charset=utf-8\"\n      %Plug.Conn{conn | resp_headers: [{\"content-type\", content_type}|resp_headers]}\n    end\n  end\n\n  @doc \"\"\"\n  Puts the url string or `%URI{}` to be used for route generation.\n\n  This function overrides the default URL generation pulled\n  from the `%Plug.Conn{}`'s endpoint configuration.\n\n  ## Examples\n\n  Imagine your application is configured to run on \"example.com\"\n  but after the user signs in, you want all links to use\n  \"some_user.example.com\". You can do so by setting the proper\n  router url configuration:\n\n      def put_router_url_by_user(conn) do\n        put_router_url(conn, get_user_from_conn(conn).account_name <> \".example.com\")\n      end\n\n  Now when you call `Routes.some_route_url(conn, ...)`, it will use\n  the router url set above. Keep in mind that, if you want to generate\n  routes to the *current* domain, it is preferred to use\n  `Routes.some_route_path` helpers, as those are always relative.\n  \"\"\"\n  def put_router_url(conn, %URI{} = uri) do\n    put_private(conn, :phoenix_router_url, URI.to_string(uri))\n  end\n  def put_router_url(conn, url) when is_binary(url) do\n    put_private(conn, :phoenix_router_url, url)\n  end\n\n  @doc \"\"\"\n  Puts the URL or `%URI{}` to be used for the static url generation.\n\n  Using this function on a `%Plug.Conn{}` struct tells `static_url\/2` to use\n  the given information for URL generation instead of the `%Plug.Conn{}`'s\n  endpoint configuration (much like `put_router_url\/2` but for static URLs).\n  \"\"\"\n  def put_static_url(conn, %URI{} = uri) do\n    put_private(conn, :phoenix_static_url, URI.to_string(uri))\n  end\n  def put_static_url(conn, url) when is_binary(url) do\n    put_private(conn, :phoenix_static_url, url)\n  end\n\n  @doc \"\"\"\n  Puts the format in the connection.\n\n  This format is used when rendering a template as an atom.\n  For example, `render(conn, :foo)` will render `\"foo.FORMAT\"`\n  where the format is the one set here. The default format\n  is typically set from the negotiation done in `accepts\/2`.\n\n  See `get_format\/1` for retrieval.\n  \"\"\"\n  def put_format(conn, format), do: put_private(conn, :phoenix_format, format)\n\n  @doc \"\"\"\n  Returns the request format, such as \"json\", \"html\".\n\n  This format is used when rendering a template as an atom.\n  For example, `render(conn, :foo)` will render `\"foo.FORMAT\"`\n  where the format is the one set here. The default format\n  is typically set from the negotiation done in `accepts\/2`.\n  \"\"\"\n  def get_format(conn) do\n    conn.private[:phoenix_format] || conn.params[\"_format\"]\n  end\n\n  @doc \"\"\"\n  Sends the given file or binary as a download.\n\n  The second argument must be `{:binary, contents}`, where\n  `contents` will be sent as download, or`{:file, path}`,\n  where `path` is the filesystem location of the file to\n  be sent. Be careful to not interpolate the path from\n  external parameters, as it could allow traversal of the\n  filesystem.\n\n  The download is achieved by setting \"content-disposition\"\n  to attachment. The \"content-type\" will also be set based\n  on the extension of the given filename but can be customized\n  via the `:content_type` and `:charset` options.\n\n  ## Options\n\n    * `:filename` - the filename to be presented to the user\n      as download\n    * `:content_type` - the content type of the file or binary\n      sent as download. It is automatically inferred from the\n      filename extension\n    * `:disposition` - specifies disposition type\n      (`:attachment` or `:inline`). If `:attachment` was used,\n      user will be prompted to save the file. If `:inline` was used,\n      the browser will attempt to open the file.\n      Defaults to `:attachment`.\n    * `:charset` - the charset of the file, such as \"utf-8\".\n      Defaults to none\n    * `:offset` - the bytes to offset when reading. Defaults to `0`\n    * `:length` - the total bytes to read. Defaults to `:all`\n    * `:encode` - encodes the filename using `URI.encode_www_form\/1`.\n      Defaults to `true`. When `false`, disables encoding. If you\n      disable encoding, you need to guarantee there are no special\n      characters in the filename, such as quotes, newlines, etc.\n      Otherwise you can expose your application to security attacks\n\n  ## Examples\n\n  To send a file that is stored inside your application priv\n  directory:\n\n      path = Application.app_dir(:my_app, \"priv\/prospectus.pdf\")\n      send_download(conn, {:file, path})\n\n  When using `{:file, path}`, the filename is inferred from the\n  given path but may also be set explicitly.\n\n  To allow the user to download contents that are in memory as\n  a binary or string:\n\n      send_download(conn, {:binary, \"world\"}, filename: \"hello.txt\")\n\n  See `Plug.Conn.send_file\/3` and `Plug.Conn.send_resp\/3` if you\n  would like to access the low-level functions used to send files\n  and responses via Plug.\n  \"\"\"\n  def send_download(conn, kind, opts \\\\ [])\n\n  def send_download(conn, {:file, path}, opts) do\n    filename = opts[:filename] || Path.basename(path)\n    offset = opts[:offset] || 0\n    length = opts[:length] || :all\n    conn\n    |> prepare_send_download(filename, opts)\n    |> send_file(conn.status || 200, path, offset, length)\n  end\n\n  def send_download(conn, {:binary, contents}, opts) do\n    filename = opts[:filename] || raise \":filename option is required when sending binary download\"\n    conn\n    |> prepare_send_download(filename, opts)\n    |> send_resp(conn.status || 200, contents)\n  end\n\n  defp prepare_send_download(conn, filename, opts) do\n    content_type = opts[:content_type] || MIME.from_path(filename)\n    encoded_filename = encode_filename(filename, Keyword.get(opts, :encode, true))\n    disposition_type = get_disposition_type(Keyword.get(opts, :disposition, :attachment))\n    warn_if_ajax(conn)\n    conn\n    |> put_resp_content_type(content_type, opts[:charset])\n    |> put_resp_header(\"content-disposition\", ~s[#{disposition_type}; filename=\"#{encoded_filename}\"])\n  end\n\n  defp encode_filename(filename, false), do: filename\n  defp encode_filename(filename, true), do: URI.encode_www_form(filename)\n\n  defp get_disposition_type(:attachment), do: \"attachment\"\n  defp get_disposition_type(:inline), do: \"inline\"\n  defp get_disposition_type(other), do: raise ArgumentError, \"expected :disposition to be :attachment or :inline, got: #{inspect(other)}\"\n\n  defp ajax?(conn) do\n    case get_req_header(conn, \"x-requested-with\") do\n      [value] -> value in [\"XMLHttpRequest\", \"xmlhttprequest\"]\n      [] -> false\n    end\n  end\n\n  defp warn_if_ajax(conn) do\n    if ajax?(conn) do\n      Logger.warning \"send_download\/3 has been invoked during an AJAX request. \" <>\n                  \"The download may not work as expected under XMLHttpRequest\"\n    end\n  end\n\n  @doc \"\"\"\n  Scrubs the parameters from the request.\n\n  This process is two-fold:\n\n    * Checks to see if the `required_key` is present\n    * Changes empty parameters of `required_key` (recursively) to nils\n\n  This function is useful for removing empty strings sent\n  via HTML forms. If you are providing an API, there\n  is likely no need to invoke `scrub_params\/2`.\n\n  If the `required_key` is not present, it will\n  raise `Phoenix.MissingParamError`.\n\n  ## Examples\n\n      iex> scrub_params(conn, \"user\")\n\n  \"\"\"\n  @spec scrub_params(Plug.Conn.t, String.t) :: Plug.Conn.t\n  def scrub_params(conn, required_key) when is_binary(required_key) do\n    param = Map.get(conn.params, required_key) |> scrub_param()\n\n    unless param do\n      raise Phoenix.MissingParamError, key: required_key\n    end\n\n    params = Map.put(conn.params, required_key, param)\n    %Plug.Conn{conn | params: params}\n  end\n\n  defp scrub_param(%{__struct__: mod} = struct) when is_atom(mod) do\n    struct\n  end\n  defp scrub_param(%{} = param) do\n    Enum.reduce(param, %{}, fn({k, v}, acc) ->\n      Map.put(acc, k, scrub_param(v))\n    end)\n  end\n  defp scrub_param(param) when is_list(param) do\n    Enum.map(param, &scrub_param\/1)\n  end\n  defp scrub_param(param) do\n    if scrub?(param), do: nil, else: param\n  end\n\n  defp scrub?(\" \" <> rest), do: scrub?(rest)\n  defp scrub?(\"\"), do: true\n  defp scrub?(_), do: false\n\n\n  @doc \"\"\"\n  Enables CSRF protection.\n\n  Currently used as a wrapper function for `Plug.CSRFProtection`\n  and mainly serves as a function plug in `YourApp.Router`.\n\n  Check `get_csrf_token\/0` and `delete_csrf_token\/0` for\n  retrieving and deleting CSRF tokens.\n  \"\"\"\n  def protect_from_forgery(conn, opts \\\\ []) do\n    Plug.CSRFProtection.call(conn, Plug.CSRFProtection.init(opts))\n  end\n\n  @doc \"\"\"\n  Put headers that improve browser security.\n\n  It sets the following headers:\n\n    * `referrer-policy` - only send origin on cross origin requests\n    * `x-frame-options` - set to SAMEORIGIN to avoid clickjacking\n      through iframes unless in the same origin\n    * `x-content-type-options` - set to nosniff. This requires\n      script and style tags to be sent with proper content type\n    * `x-download-options` - set to noopen to instruct the browser\n      not to open a download directly in the browser, to avoid\n      HTML files rendering inline and accessing the security\n      context of the application (like critical domain cookies)\n    * `x-permitted-cross-domain-policies` - set to none to restrict\n      Adobe Flash Player’s access to data\n\n  A custom headers map may also be given to be merged with defaults.\n  It is recommended for custom header keys to be in lowercase, to avoid sending\n  duplicate keys in a request.\n  Additionally, responses with mixed-case headers served over HTTP\/2 are not\n  considered valid by common clients, resulting in dropped responses.\n  \"\"\"\n  def put_secure_browser_headers(conn, headers \\\\ %{})\n  def put_secure_browser_headers(conn, []) do\n    put_secure_defaults(conn)\n  end\n  def put_secure_browser_headers(conn, headers) when is_map(headers) do\n    conn\n    |> put_secure_defaults()\n    |> merge_resp_headers(headers)\n  end\n  defp put_secure_defaults(conn) do\n    merge_resp_headers(conn, [\n      # Below is the default from November 2020 but not yet in Safari as in Jan\/2022.\n      # https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Headers\/Referrer-Policy\n      {\"referrer-policy\", \"strict-origin-when-cross-origin\"},\n      {\"x-content-type-options\", \"nosniff\"},\n      # Applies only to Internet Explorer, can safely be removed in the future.\n      {\"x-download-options\", \"noopen\"},\n      {\"x-frame-options\", \"SAMEORIGIN\"},\n      {\"x-permitted-cross-domain-policies\", \"none\"}\n    ])\n  end\n\n  @doc \"\"\"\n  Gets or generates a CSRF token.\n\n  If a token exists, it is returned, otherwise it is generated and stored\n  in the process dictionary.\n  \"\"\"\n  defdelegate get_csrf_token(), to: Plug.CSRFProtection\n\n  @doc \"\"\"\n  Deletes the CSRF token from the process dictionary.\n\n  *Note*: The token is deleted only after a response has been sent.\n  \"\"\"\n  defdelegate delete_csrf_token(), to: Plug.CSRFProtection\n\n  @doc \"\"\"\n  Performs content negotiation based on the available formats.\n\n  It receives a connection, a list of formats that the server\n  is capable of rendering and then proceeds to perform content\n  negotiation based on the request information. If the client\n  accepts any of the given formats, the request proceeds.\n\n  If the request contains a \"_format\" parameter, it is\n  considered to be the format desired by the client. If no\n  \"_format\" parameter is available, this function will parse\n  the \"accept\" header and find a matching format accordingly.\n\n  This function is useful when you may want to serve different\n  content-types (such as JSON and HTML) from the same routes.\n  However, if you always have distinct routes, you can also\n  disable content negotiation and simply hardcode your format\n  of choice in your route pipelines:\n\n      plug :put_format, \"html\"\n\n  It is important to notice that browsers have historically\n  sent bad accept headers. For this reason, this function will\n  default to \"html\" format whenever:\n\n    * the accepted list of arguments contains the \"html\" format\n\n    * the accept header specified more than one media type preceded\n      or followed by the wildcard media type \"`*\/*`\"\n\n  This function raises `Phoenix.NotAcceptableError`, which is rendered\n  with status 406, whenever the server cannot serve a response in any\n  of the formats expected by the client.\n\n  ## Examples\n\n  `accepts\/2` can be invoked as a function:\n\n      iex> accepts(conn, [\"html\", \"json\"])\n\n  or used as a plug:\n\n      plug :accepts, [\"html\", \"json\"]\n      plug :accepts, ~w(html json)\n\n  ## Custom media types\n\n  It is possible to add custom media types to your Phoenix application.\n  The first step is to teach Plug about those new media types in\n  your `config\/config.exs` file:\n\n      config :mime, :types, %{\n        \"application\/vnd.api+json\" => [\"json-api\"]\n      }\n\n  The key is the media type, the value is a list of formats the\n  media type can be identified with. For example, by using\n  \"json-api\", you will be able to use templates with extension\n  \"index.json-api\" or to force a particular format in a given\n  URL by sending \"?_format=json-api\".\n\n  After this change, you must recompile plug:\n\n      $ mix deps.clean mime --build\n      $ mix deps.get\n\n  And now you can use it in accepts too:\n\n      plug :accepts, [\"html\", \"json-api\"]\n\n  \"\"\"\n  @spec accepts(Plug.Conn.t, [binary]) :: Plug.Conn.t\n  def accepts(conn, [_|_] = accepted) do\n    case Map.fetch(conn.params, \"_format\") do\n      {:ok, format} ->\n        handle_params_accept(conn, format, accepted)\n      :error ->\n        handle_header_accept(conn, get_req_header(conn, \"accept\"), accepted)\n    end\n  end\n\n  defp handle_params_accept(conn, format, accepted) do\n    if format in accepted do\n      put_format(conn, format)\n    else\n      raise Phoenix.NotAcceptableError,\n        message: \"unknown format #{inspect format}, expected one of #{inspect accepted}\",\n        accepts: accepted\n    end\n  end\n\n  # In case there is no accept header or the header is *\/*\n  # we use the first format specified in the accepts list.\n  defp handle_header_accept(conn, header, [first|_]) when header == [] or header == [\"*\/*\"] do\n    put_format(conn, first)\n  end\n\n  # In case there is a header, we need to parse it.\n  # But before we check for *\/* because if one exists and we serve html,\n  # we unfortunately need to assume it is a browser sending us a request.\n  defp handle_header_accept(conn, [header|_], accepted) do\n    if header =~ \"*\/*\" and \"html\" in accepted do\n      put_format(conn, \"html\")\n    else\n      parse_header_accept(conn, String.split(header, \",\"), [], accepted)\n    end\n  end\n\n  defp parse_header_accept(conn, [h|t], acc, accepted) do\n    case Plug.Conn.Utils.media_type(h) do\n      {:ok, type, subtype, args} ->\n        exts = parse_exts(type, subtype)\n        q    = parse_q(args)\n\n        if format = (q === 1.0 && find_format(exts, accepted)) do\n          put_format(conn, format)\n        else\n          parse_header_accept(conn, t, [{-q, h, exts}|acc], accepted)\n        end\n      :error ->\n        parse_header_accept(conn, t, acc, accepted)\n    end\n  end\n\n  defp parse_header_accept(conn, [], acc, accepted) do\n    acc\n    |> Enum.sort()\n    |> Enum.find_value(&parse_header_accept(conn, &1, accepted))\n    |> Kernel.||(refuse(conn, acc, accepted))\n  end\n\n  defp parse_header_accept(conn, {_, _, exts}, accepted) do\n    if format = find_format(exts, accepted) do\n      put_format(conn, format)\n    end\n  end\n\n  defp parse_q(args) do\n    case Map.fetch(args, \"q\") do\n      {:ok, float} ->\n        case Float.parse(float) do\n          {float, _} -> float\n          :error -> 1.0\n        end\n      :error ->\n        1.0\n    end\n  end\n\n  defp parse_exts(\"*\", \"*\"),      do: \"*\/*\"\n  defp parse_exts(type, \"*\"),     do: type\n  defp parse_exts(type, subtype), do: MIME.extensions(type <> \"\/\" <> subtype)\n\n  defp find_format(\"*\/*\", accepted),                   do: Enum.fetch!(accepted, 0)\n  defp find_format(exts, accepted) when is_list(exts), do: Enum.find(exts, &(&1 in accepted))\n  defp find_format(_type_range, []),                   do: nil\n  defp find_format(type_range, [h|t]) do\n    mime_type = MIME.type(h)\n    case Plug.Conn.Utils.media_type(mime_type) do\n      {:ok, accepted_type, _subtype, _args} when type_range === accepted_type -> h\n      _ -> find_format(type_range, t)\n    end\n  end\n\n  @spec refuse(term(), [tuple], [binary]) :: no_return()\n  defp refuse(_conn, given, accepted) do\n    raise Phoenix.NotAcceptableError,\n      accepts: accepted,\n      message: \"\"\"\n      no supported media type in accept header.\n\n      Expected one of #{inspect accepted} but got the following formats:\n\n        * #{Enum.map_join(given, \"\\n  \", fn {_, header, exts} ->\n              inspect(header) <> \" with extensions: \" <> inspect(exts)\n            end)}\n\n      To accept custom formats, register them under the :mime library\n      in your config\/config.exs file:\n\n          config :mime, :types, %{\n            \"application\/xml\" => [\"xml\"]\n          }\n\n      And then run `mix deps.clean --build mime` to force it to be recompiled.\n      \"\"\"\n  end\n\n  @doc \"\"\"\n  Fetches the flash storage.\n  \"\"\"\n  def fetch_flash(conn, _opts \\\\ []) do\n    if Map.get(conn.private, :phoenix_flash) do\n      conn\n    else\n      session_flash = get_session(conn, \"phoenix_flash\")\n      conn = persist_flash(conn, session_flash || %{})\n\n      register_before_send conn, fn conn ->\n        flash = conn.private.phoenix_flash\n        flash_size = map_size(flash)\n\n        cond do\n          is_nil(session_flash) and flash_size == 0 ->\n            conn\n          flash_size > 0 and conn.status in 300..308 ->\n            put_session(conn, \"phoenix_flash\", flash)\n          true ->\n            delete_session(conn, \"phoenix_flash\")\n        end\n      end\n    end\n  end\n\n  @doc \"\"\"\n  Merges a map into the flash.\n\n  Returns the updated connection.\n\n  ## Examples\n\n      iex> conn = merge_flash(conn, info: \"Welcome Back!\")\n      iex> get_flash(conn, :info)\n      \"Welcome Back!\"\n\n  \"\"\"\n  def merge_flash(conn, enumerable) do\n    map = for {k, v} <- enumerable, into: %{}, do: {flash_key(k), v}\n    persist_flash(conn, Map.merge(get_flash(conn), map))\n  end\n\n  @doc \"\"\"\n  Persists a value in flash.\n\n  Returns the updated connection.\n\n  ## Examples\n\n      iex> conn = put_flash(conn, :info, \"Welcome Back!\")\n      iex> get_flash(conn, :info)\n      \"Welcome Back!\"\n\n  \"\"\"\n  def put_flash(conn, key, message) do\n    persist_flash(conn, Map.put(get_flash(conn), flash_key(key), message))\n  end\n\n  @doc \"\"\"\n  Returns a map of previously set flash messages or an empty map.\n\n  ## Examples\n\n      iex> get_flash(conn)\n      %{}\n\n      iex> conn = put_flash(conn, :info, \"Welcome Back!\")\n      iex> get_flash(conn)\n      %{\"info\" => \"Welcome Back!\"}\n\n  \"\"\"\n  def get_flash(conn) do\n    Map.get(conn.private, :phoenix_flash) ||\n      raise ArgumentError, message: \"flash not fetched, call fetch_flash\/2\"\n  end\n\n  @doc \"\"\"\n  Returns a message from flash by `key` (or `nil` if no message is available for `key`).\n\n  ## Examples\n\n      iex> conn = put_flash(conn, :info, \"Welcome Back!\")\n      iex> get_flash(conn, :info)\n      \"Welcome Back!\"\n\n  \"\"\"\n  def get_flash(conn, key) do\n    get_flash(conn)[flash_key(key)]\n  end\n\n  @doc \"\"\"\n  Generates a status message from the template name.\n\n  ## Examples\n\n      iex> status_message_from_template(\"404.html\")\n      \"Not Found\"\n      iex> status_message_from_template(\"whatever.html\")\n      \"Internal Server Error\"\n\n  \"\"\"\n  def status_message_from_template(template) do\n    template\n    |> String.split(\".\")\n    |> hd()\n    |> String.to_integer()\n    |> Plug.Conn.Status.reason_phrase()\n  rescue\n    _ -> \"Internal Server Error\"\n  end\n\n  @doc \"\"\"\n  Clears all flash messages.\n  \"\"\"\n  def clear_flash(conn) do\n    persist_flash(conn, %{})\n  end\n\n  defp flash_key(binary) when is_binary(binary), do: binary\n  defp flash_key(atom) when is_atom(atom), do: Atom.to_string(atom)\n\n  defp persist_flash(conn, value) do\n    put_private(conn, :phoenix_flash, value)\n  end\n\n  @doc \"\"\"\n  Returns the current request path with its default query parameters:\n\n      iex> current_path(conn)\n      \"\/users\/123?existing=param\"\n\n  See `current_path\/2` to override the default parameters.\n\n  The path is normalized based on the `conn.script_name` and\n  `conn.path_info`. For example, \"\/foo\/\/bar\/\" will become \"\/foo\/bar\".\n  If you want the original path, use `conn.request_path` instead.\n  \"\"\"\n  def current_path(%Plug.Conn{query_string: \"\"} = conn) do\n    normalized_request_path(conn)\n  end\n\n  def current_path(%Plug.Conn{query_string: query_string} = conn) do\n    normalized_request_path(conn) <> \"?\" <> query_string\n  end\n\n  @doc \"\"\"\n  Returns the current path with the given query parameters.\n\n  You may also retrieve only the request path by passing an\n  empty map of params.\n\n  ## Examples\n\n      iex> current_path(conn)\n      \"\/users\/123?existing=param\"\n\n      iex> current_path(conn, %{new: \"param\"})\n      \"\/users\/123?new=param\"\n\n      iex> current_path(conn, %{filter: %{status: [\"draft\", \"published\"]}})\n      \"\/users\/123?filter[status][]=draft&filter[status][]=published\"\n\n      iex> current_path(conn, %{})\n      \"\/users\/123\"\n\n  The path is normalized based on the `conn.script_name` and\n  `conn.path_info`. For example, \"\/foo\/\/bar\/\" will become \"\/foo\/bar\".\n  If you want the original path, use `conn.request_path` instead.\n  \"\"\"\n  def current_path(%Plug.Conn{} = conn, params) when params == %{} do\n    normalized_request_path(conn)\n  end\n  def current_path(%Plug.Conn{} = conn, params) do\n    normalized_request_path(conn) <> \"?\" <> Plug.Conn.Query.encode(params)\n  end\n\n  defp normalized_request_path(%{path_info: info, script_name: script}) do\n    \"\/\" <> Enum.join(script ++ info, \"\/\")\n  end\n\n  @doc \"\"\"\n  Returns the current request url with its default query parameters:\n\n      iex> current_url(conn)\n      \"https:\/\/www.example.com\/users\/123?existing=param\"\n\n  See `current_url\/2` to override the default parameters.\n  \"\"\"\n  def current_url(%Plug.Conn{} = conn) do\n    Phoenix.VerifiedRoutes.unverified_url(conn, current_path(conn))\n  end\n\n  @doc ~S\"\"\"\n  Returns the current request URL with query params.\n\n  The path will be retrieved from the currently requested path via\n  `current_path\/1`. The scheme, host and others will be received from\n  the URL configuration in your Phoenix endpoint. The reason we don't\n  use the host and scheme information in the request is because most\n  applications are behind proxies and the host and scheme may not\n  actually reflect the host and scheme accessed by the client. If you\n  want to access the url precisely as requested by the client, see\n  `Plug.Conn.request_url\/1`.\n\n  ## Examples\n\n      iex> current_url(conn)\n      \"https:\/\/www.example.com\/users\/123?existing=param\"\n\n      iex> current_url(conn, %{new: \"param\"})\n      \"https:\/\/www.example.com\/users\/123?new=param\"\n\n      iex> current_url(conn, %{})\n      \"https:\/\/www.example.com\/users\/123\"\n\n  ## Custom URL Generation\n\n  In some cases, you'll need to generate a request's URL, but using a\n  different scheme, different host, etc. This can be accomplished in\n  two ways.\n\n  If you want to do so in a case-by-case basis, you can define a custom\n  function that gets the endpoint URI configuration and changes it accordingly.\n  For example, to get the current URL always in HTTPS format:\n\n      def current_secure_url(conn, params \\\\ %{}) do\n        current_uri = MyAppWeb.Endpoint.struct_url()\n        current_path = Phoenix.Controller.current_path(conn, params)\n        Phoenix.VerifiedRoutes.unverified_url(%URI{current_uri | scheme: \"https\"}, current_path)\n      end\n\n  However, if you want all generated URLs to always have a certain schema,\n  host, etc, you may use `put_router_url\/2`.\n  \"\"\"\n  def current_url(%Plug.Conn{} = conn, %{} = params) do\n    Phoenix.VerifiedRoutes.unverified_url(conn, current_path(conn, params))\n  end\n\n  @doc false\n  def __view__(controller_module) do\n    controller_module\n    |> Phoenix.Naming.unsuffix(\"Controller\")\n    |> Kernel.<>(\"View\")\n    |> String.to_atom()\n  end\n\n  @doc false\n  def __layout__(controller_module, opts) do\n    namespace =\n      if given = Keyword.get(opts, :namespace) do\n        given\n      else\n        controller_module\n        |> Atom.to_string()\n        |> String.split(\".\")\n        |> Enum.drop(-1)\n        |> Enum.take(2)\n        |> Module.concat()\n      end\n    Module.concat(namespace, \"LayoutView\")\n  end\nend\n","languageId":"elixir","uri":"file:\/\/\/Users\/mitchell\/src\/phoenix\/lib\/phoenix\/controller.ex"}}}Content-Length: 55\r\n\r\n
